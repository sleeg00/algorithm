// 이전에 K 이동 => k-1 OR k+1 , K만 이동이 가능하다
// 0시작 : -1, 0, 1이지만 음수, 0은 무의미하다
// 0, 1, 2, => 1, 2, 3
// x -> y 까지 최소한의 작동 횟수로 이동한다.
// 유의사항 : y지점에서 도착해서는 공간 이동장치 안전을 위해 반드시 직전 이동거리는 1로 한다
// 0 <= x < y < INT_MAX
// 11:20
// + + + + - - - - 가 되야하기 때문에 특정 중간값이 >크면 안된다
// 0 -> 3
// 이동 거리 : 0  1  2  3
// 이동 장치 : 0  1  1  1
// 1 -> 5 => 3
// 이동 거리 : 1  2  4  5
// 이동 장치 : 0  1  2  1

// 45 -> 50
// 이동 거리 : 45  46  48  49 50
// 이동 장치 : 0    1  2    1  1

// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
// (Y-X)/2+1 + 만약 (Y-X)%2==1, +1
// 0 ->5
// 0 1 3 4 5
// 0 1 2 1 1

// 3 -> 9
// 3 4 6 8 9

// 0 1 2 2 1 => 4

// 2 3 5 8 12 17 22 27 31 34  37  39 40
// 0 1 2 3  4  5  5  5  4  3  3   2  1

// 2 3 5 8 12 17 22 27 31 34 36 38  40 41 =>43/2 = >21
// 0 1 2 3  4  5  5  5  4  3  2  2   2 1
//(X+Y)/2 *2
#include <algorithm>
#include <iostream>

using namespace std;

int T;
long long x, y;
int main(void) {
    cin >> T;
    for(int i=0; i<T; i++) {
        cin >> x >> y;
        long long p = 0;
        while(p*p <= (y-x))
            p++;
        p--;
        int value = 2*p-1;
        long long r = y-x-p*p;
        value += (long long)ceil((double)r/(double)p);
        cout << value << '\n';
    }
}